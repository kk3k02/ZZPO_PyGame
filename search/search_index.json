{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ZZPO","text":"<p>Celem naszego projektu jest stworzenie gry 2D kt\u00f3rej logika jest wzorowana na popularnej grze \u201cAsteroids\u201d. W naszej grze gracz wciela si\u0119 w posta\u0107 z popularnej kresk\u00f3wki i walczy ze z\u0142ymi bakteriami i wirusami.</p>"},{"location":"#wymagania-funkcjonalne","title":"Wymagania funkcjonalne","text":"<ul> <li>Gracz mo\u017ce kontrolowa\u0107 swoj\u0105 posta\u0107 poprzez ruch prz\u00f3d, ty\u0142, obr\u00f3t w prawo, obr\u00f3t w lewo oraz strza\u0142.</li> <li>Gra generuje losowych przeciwnik\u00f3w, kt\u00f3rzy poruszaj\u0105 si\u0119 ruchem jednostajnym prostoliniowym.</li> <li>Gracz mo\u017ce niszczy\u0107 przeciwnik\u00f3w poprzez strzelanie do nich.</li> <li>Niekt\u00f3rzy przeciwnicy r\u00f3wnie\u017c posiadaj\u0105 mo\u017cliwo\u015b\u0107 strzelania.</li> <li>Przeciwnik po trafieniu rozpada si\u0119 na mniejsze cz\u0119\u015bci lub ulega ca\u0142kowitemu zniszczeniu.</li> <li>Gracz traci \u017cycia w momencie zderzenia lub trafieniu wrogim pociskiem.</li> <li>Gracz zwi\u0119ksza sw\u00f3j wynik poprzez trafianie przeciwnik\u00f3w.</li> </ul>"},{"location":"#wymagania-niefunkcjonalne","title":"Wymagania niefunkcjonalne","text":"<ul> <li>Gra desktopowa, napisana w j\u0119zyku python z wykorzystaniem biblioteki pygames.</li> </ul>"},{"location":"#pojecia","title":"Poj\u0119cia","text":"<ul> <li><code>Gracz</code>: posta\u0107 sterowana przez osob\u0119 graj\u0105c\u0105 w gr\u0119.</li> <li><code>Przeciwnik</code>: posta\u0107 sterowana przez komputer.</li> <li><code>Trafienie</code>: kolizja pocisku z graczem lub przeciwnikiem.</li> <li><code>Zderzenie</code>: kolizja gracza z przeciwnikiem.</li> <li><code>Obra\u017cenia</code>: \u0142\u0105czna suma zderze\u0144 i kolizji gracza z przeciwnikiem.</li> <li><code>\u017bycia</code>: maksymalna ilo\u015b\u0107 obra\u017ce\u0144 mo\u017cliwa do przyj\u0119cia.</li> <li><code>Wynik</code>: suma punkt\u00f3w uzyskanych za trafienia przeciwnik\u00f3w.</li> </ul>"},{"location":"docs/","title":"Dokumentacja kodu","text":"<p>W projekcje zdecywowano si\u0119 wykorzysta\u0107 nowe standardy Pythona zwi\u0105zane z dokumentacj\u0105 kodu. Poni\u017cej znajduje si\u0119 opis konwencji oraz wykorzystane narz\u0119dzia do automatycznej generacji dokumentacji z kodu.</p>"},{"location":"docs/#dokumentowanie-kodu-za-pomoca-docstringow","title":"Dokumentowanie kodu za pomoc\u0105 docstring\u00f3w","text":"<p>Konwencja Pythona PEP 257 wyja\u015bnia spos\u00f3b dokumentacji kodu. Zgodnie z t\u0105 konwencj\u0105 ka\u017cdy modu\u0142, klasa oraz funkcja powinny posiada\u0107 komentarz dokumentacyjny - tak zwany docstring. Jego tre\u015b\u0107 jest umieszczona pomi\u0119dzy potr\u00f3jnymi znakami cudzys\u0142ow\u00f3w <code>\"\"\" \"\"\"</code>. W docstringu znajduje si\u0119 opis dzia\u0142ania, przyjmowanych argument\u00f3w oraz zwracanych warto\u015bci. S\u0105 r\u00f3\u017cne style pisania docstring\u00f3w. W niniejszym projekcje zdecydowano si\u0119 na styl zaproponowany przez Google ze wzgl\u0119du na jego przejrzysto\u015b\u0107.</p> <p>Na poni\u017cszym listingu widnieje przyk\u0142adowy docstring napisany w stylu Google.</p> <pre><code>def fetch_smalltable_rows(\n    table_handle: smalltable.Table,\n    keys: Sequence[bytes | str],\n    require_all_keys: bool = False,\n) -&gt; Mapping[bytes, tuple[str, ...]]:\n    \"\"\"Fetches rows from a Smalltable.\n\n    Retrieves rows pertaining to the given keys from the Table instance\n    represented by table_handle.  String keys will be UTF-8 encoded.\n\n    Args:\n        table_handle: An open smalltable.Table instance.\n        keys: A sequence of strings representing the key of each table\n          row to fetch.  String keys will be UTF-8 encoded.\n        require_all_keys: If True only rows with values set for all keys will be\n          returned.\n\n    Returns:\n        A dict mapping keys to the corresponding table row data\n        fetched. Each row is represented as a tuple of strings. For\n        example:\n\n        {b'Serak': ('Rigel VII', 'Preparer'),\n         b'Zim': ('Irk', 'Invader'),\n         b'Lrrr': ('Omicron Persei 8', 'Emperor')}\n\n        Returned keys are always bytes.  If a key from the keys argument is\n        missing from the dictionary, then that row was not found in the\n        table (and require_all_keys must have been False).\n\n    Raises:\n        IOError: An error occurred accessing the smalltable.\n    \"\"\"\n</code></pre>"},{"location":"docs/#generowanie-dokumentacji-z-kodu","title":"Generowanie dokumentacji z kodu","text":"<p>Do tego celu by\u0142y rozwa\u017cane 2 powszechne narz\u0119dzia - Sphinx oraz MkDocs. Oba narz\u0119dzia pozwalaj\u0105 na generowanie dokumentacji z kodu na podstawie wcze\u015bniej przygotowanych docstring\u00f3w. Sphinx zwykle wykorzystywany w du\u017cych projektach ze wzgl\u0119du na mo\u017cliwo\u015b\u0107 wi\u0119kszego dostowowania jego opcji do w\u0142asnych potrzeb, co jednak mocno komplikuje jego konfiguracj\u0119. Z tego powodu zdecydowano si\u0119 na MkDocs ze wzgl\u0119du na bardziej intuicyjna konfiguracj\u0119 oraz wsparcie dla markdowna.</p> <p>MkDocs to szybki i prosty generator statycznych stron internetowych, kt\u00f3ry jest przeznaczony do tworzenia dokumentacji projektu. Pliki \u017ar\u00f3d\u0142owe dokumentacji s\u0105 pisane w Markdown i konfigurowane za pomoc\u0105 pojedynczego pliku konfiguracyjnego YAML.</p>"},{"location":"docs/#struktua-plikow-zwiazanych-z-mkdocs","title":"Struktua plik\u00f3w zwi\u0105zanych z MkDocs","text":"<pre><code>\u251c\u2500\u2500 docs\n\u2502   \u251c\u2500\u2500 api_reference\n\u2502   \u2502   \u251c\u2500\u2500 bullet_reference.md\n\u2502   \u2502   \u251c\u2500\u2500 cell_reference.md\n\u2502   \u2502   \u251c\u2500\u2500 enemy_bullet_reference.md\n\u2502   \u2502   \u251c\u2500\u2500 enemy_reference.md\n\u2502   \u2502   \u251c\u2500\u2500 player_reference.md\n\u2502   \u2502   \u2514\u2500\u2500 virus_reference.md\n\u2502   \u251c\u2500\u2500 docs.md\n\u2502   \u2514\u2500\u2500 index.md\n\u251c\u2500\u2500 src\n\u2514\u2500\u2500 mkdocs.yml\n</code></pre>"},{"location":"docs/#struktura-pliku-konfiguracyjnego-mkdocsyml","title":"Struktura pliku konfiguracyjnego <code>mkdocs.yml</code>","text":"<p>MkDocs konfigurowane jest za pomoc\u0105 jednego pliku. Poni\u017cej przedstawiono plik konfiguracyjny naszego projektu.</p> <pre><code># Nazwa projektu\nsite_name: ZZPO Project documentation\ncopyright: ZZPO Team\n\n# Konfiguracja wygl\u0105du strony\ntheme:\n  name: \"material\"\n  palette:\n    # Palette toggle for light mode\n    - scheme: default\n      toggle:\n        icon: material/brightness-7\n        name: Switch to dark mode\n    # Palette toggle for dark mode\n    - scheme: slate\n      toggle:\n        icon: material/brightness-4\n        name: Switch to light mode\n\n# Podlinkowanie plik\u00f3w z tre\u015bci\u0105 srony\nnav:\n  - Home: 'index.md'\n  - API Reference:\n    - Player: 'api_reference/player_reference.md'\n    - Virus: 'api_reference/virus_reference.md'\n    - Cell: 'api_reference/cell_reference.md'\n    - Enemy: 'api_reference/enemy_reference.md'\n    - Enemy Bullet: 'api_reference/enemy_bullet_reference.md'\n    - Bullet: 'api_reference/bullet_reference.md'\n\n# Opcjonalne wtyczki i rozszerzenia\nplugins:\n  - search\n  - mkdocstrings\n\nmarkdown_extensions:\n  - admonition\n  - pymdownx.details\n  - pymdownx.superfences\n  - pymdownx.highlight:\n      anchor_linenums: true\n      line_spans: __span\n      pygments_lang_class: true\n  - pymdownx.inlinehilite\n  - pymdownx.snippets\n  - tables\n</code></pre>"},{"location":"api_reference/bullet_reference/","title":"Bullet module","text":""},{"location":"api_reference/bullet_reference/#bullet-class","title":"Bullet class","text":"Source code in <code>src/bullet.py</code> <pre><code>class Bullet:\n    def __init__(self, sw: float, sh: float, player: Player) -&gt; None:\n        self.sw = sw  # Screen width\n        self.sh = sh  # Screen height\n        self.point = (\n            player.head\n        )  # Bullet starting point (same as player's head position)\n        self.x, self.y = self.point  # Current position of the bullet\n        self.w = 20  # Width of the bullet\n        self.h = 20  # Height of the bullet\n        self.c = (\n            player.cosine\n        )  # Cosine of the player's angle (used for bullet's horizontal velocity)\n        self.s = (\n            player.sine\n        )  # Sine of the player's angle (used for bullet's vertical velocity)\n        self.xv = self.c * 10  # Horizontal velocity of the bullet\n        self.yv = self.s * 10  # Vertical velocity of the bullet\n\n    def move(self) -&gt; None:\n        \"\"\"Move the bullet according to its velocity.\"\"\"\n        self.x += self.xv\n        self.y -= self.yv  # Subtracting yv since y-axis is inverted in pygame\n\n    def draw(self, win: Surface) -&gt; None:\n        # Draw the bullet on the screen\n        pygame.draw.circle(\n            win,\n            (255, 255, 255),\n            (self.x + self.w // 2, self.y + self.h // 2),\n            self.w // 2,\n        )\n        # Draw a circle representing the bullet with white color\n\n    def checkOffScreen(self) -&gt; bool:\n        \"\"\"Check if the bullet is off the screen.\n\n        Returns:\n            True if bullet is off the screen.\n        \"\"\"\n        if self.x &lt; -50 or self.x &gt; self.sw or self.y &gt; self.sh or self.y &lt; -50:\n            return True\n        return False\n</code></pre>"},{"location":"api_reference/bullet_reference/#src.bullet.Bullet.checkOffScreen","title":"<code>checkOffScreen()</code>","text":"<p>Check if the bullet is off the screen.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if bullet is off the screen.</p> Source code in <code>src/bullet.py</code> <pre><code>def checkOffScreen(self) -&gt; bool:\n    \"\"\"Check if the bullet is off the screen.\n\n    Returns:\n        True if bullet is off the screen.\n    \"\"\"\n    if self.x &lt; -50 or self.x &gt; self.sw or self.y &gt; self.sh or self.y &lt; -50:\n        return True\n    return False\n</code></pre>"},{"location":"api_reference/bullet_reference/#src.bullet.Bullet.move","title":"<code>move()</code>","text":"<p>Move the bullet according to its velocity.</p> Source code in <code>src/bullet.py</code> <pre><code>def move(self) -&gt; None:\n    \"\"\"Move the bullet according to its velocity.\"\"\"\n    self.x += self.xv\n    self.y -= self.yv  # Subtracting yv since y-axis is inverted in pygame\n</code></pre>"},{"location":"api_reference/cell_reference/","title":"Cell module","text":""},{"location":"api_reference/cell_reference/#cell-class","title":"Cell class","text":"<p>             Bases: <code>GameObject</code></p> Source code in <code>src/cell.py</code> <pre><code>class Cell(GameObject):\n    def __init__(self, sw: int, sh: int, image: Surface):\n        super().__init__(sw, sh, image)\n\n        # Generate a random starting point for the cell\n        self.ranPoint = random.choice(\n            [\n                (\n                    random.randrange(0, sw - self.w),\n                    random.choice([-1 * self.h - 5, sh + 5]),\n                ),\n                (\n                    random.choice([-1 * self.w - 5, sw + 5]),\n                    random.randrange(0, sh - self.h),\n                ),\n            ]\n        )\n        self.x, self.y = self.ranPoint  # Current position of the cell\n        # Determine the direction of movement based on starting point\n        if self.x &lt; sw // 2:\n            self.x_dir = (\n                1  # Move right if starting point is on the left half of the screen\n            )\n        else:\n            self.x_dir = (\n                -1\n            )  # Move left if starting point is on the right half of the screen\n        if self.y &lt; sh // 2:\n            self.y_dir = (\n                1  # Move down if starting point is on the top half of the screen\n            )\n        else:\n            self.y_dir = (\n                -1\n            )  # Move up if starting point is on the bottom half of the screen\n        self.xv = self.x_dir * 2  # Horizontal velocity of the cell\n        self.yv = self.y_dir * 2  # Vertical velocity of the cell\n\n    def draw(self, win: Surface) -&gt; None:\n        \"\"\"Draw the cell on the screen.\n\n        Args:\n            win: target window.\n        \"\"\"\n        win.blit(self.img, (self.x, self.y))\n</code></pre>"},{"location":"api_reference/cell_reference/#src.cell.Cell.draw","title":"<code>draw(win)</code>","text":"<p>Draw the cell on the screen.</p> <p>Parameters:</p> Name Type Description Default <code>win</code> <code>Surface</code> <p>target window.</p> required Source code in <code>src/cell.py</code> <pre><code>def draw(self, win: Surface) -&gt; None:\n    \"\"\"Draw the cell on the screen.\n\n    Args:\n        win: target window.\n    \"\"\"\n    win.blit(self.img, (self.x, self.y))\n</code></pre>"},{"location":"api_reference/enemy_bullet_reference/","title":"enemyBullet module","text":""},{"location":"api_reference/enemy_bullet_reference/#enemybullet-class","title":"EnemyBullet class","text":"<p>             Bases: <code>object</code></p> Source code in <code>src/enemyBullet.py</code> <pre><code>class EnemyBullet(object):\n    def __init__(self, player: Player, x: float, y: float) -&gt; None:\n        self.x = x  # Initial x-coordinate of the bullet\n        self.y = y  # Initial y-coordinate of the bullet\n        self.w = 20.0  # Width of the bullet\n        self.h = 20.0  # Height of the bullet\n\n        # Calculate the direction towards the player\n        self.dx, self.dy = player.x - self.x, player.y - self.y\n        self.dist = math.hypot(self.dx, self.dy)  # Distance between bullet and player\n        self.dx, self.dy = (\n            self.dx / self.dist,\n            self.dy / self.dist,\n        )  # Normalize the direction vector\n        self.xv = self.dx * 5  # Horizontal velocity of the bullet\n        self.yv = self.dy * 5  # Vertical velocity of the bullet\n\n    def draw(self, win: Surface) -&gt; None:\n        \"\"\"Draw the enemy bullet on the screen.\"\"\"\n        pygame.draw.circle(\n            win, (255, 0, 0), (self.x + self.w // 2, self.y + self.h // 2), self.w // 2\n        )\n</code></pre>"},{"location":"api_reference/enemy_bullet_reference/#src.enemyBullet.EnemyBullet.draw","title":"<code>draw(win)</code>","text":"<p>Draw the enemy bullet on the screen.</p> Source code in <code>src/enemyBullet.py</code> <pre><code>def draw(self, win: Surface) -&gt; None:\n    \"\"\"Draw the enemy bullet on the screen.\"\"\"\n    pygame.draw.circle(\n        win, (255, 0, 0), (self.x + self.w // 2, self.y + self.h // 2), self.w // 2\n    )\n</code></pre>"},{"location":"api_reference/enemy_reference/","title":"Enemy module","text":""},{"location":"api_reference/enemy_reference/#enemy-class","title":"Enemy class","text":"<p>             Bases: <code>GameObject</code></p> Source code in <code>src/enemy.py</code> <pre><code>class Enemy(GameObject):\n    def __init__(self, sw: int, sh: int, image: Surface) -&gt; None:\n        super().__init__(sw, sh, image)\n\n        # Generate a random starting point for the enemy\n        self.ranPoint = random.choice(\n            [\n                (\n                    random.randrange(0, sw - self.w),\n                    random.choice([-1 * self.h - 5, sh + 5]),\n                ),\n                (\n                    random.choice([-1 * self.w - 5, sw + 5]),\n                    random.randrange(0, sh - self.h),\n                ),\n            ]\n        )\n        self.x, self.y = self.ranPoint  # Current position of the enemy\n        # Determine the direction of movement based on starting point\n        if self.x &lt; sw // 2:\n            self.x_dir = (\n                1  # Move right if starting point is on the left half of the screen\n            )\n        else:\n            self.x_dir = (\n                -1\n            )  # Move left if starting point is on the right half of the screen\n        if self.y &lt; sh // 2:\n            self.y_dir = (\n                1  # Move down if starting point is on the top half of the screen\n            )\n        else:\n            self.y_dir = (\n                -1\n            )  # Move up if starting point is on the bottom half of the screen\n        self.xv = self.x_dir * 2  # Horizontal velocity of the enemy\n        self.yv = self.y_dir * 2  # Vertical velocity of the enemy\n\n    def draw(self, win: Surface) -&gt; None:\n        # Draw the enemy on the screen\n        win.blit(self.img, (self.x, self.y))\n</code></pre>"},{"location":"api_reference/player_reference/","title":"Player module","text":""},{"location":"api_reference/player_reference/#direction-class","title":"Direction class","text":"<p>             Bases: <code>StrEnum</code></p> Source code in <code>src/player.py</code> <pre><code>class Direction(StrEnum):\n    FORWARD = \"forward\"\n    BACKWARD = \"backward\"\n    LEFT = \"left\"\n    RIGHT = \"right\"\n</code></pre>"},{"location":"api_reference/player_reference/#player-class","title":"Player class","text":"<p>             Bases: <code>GameObject</code></p> <p>The class representing a character controlled by the player.</p> Source code in <code>src/player.py</code> <pre><code>class Player(GameObject):\n    \"\"\"The class representing a character controlled by the player.\"\"\"\n\n    def __init__(self, sw: int, sh: int, image: Surface) -&gt; None:\n        super().__init__(sw, sh, image)\n        self.x: int = sw // 2  # Initial x-coordinate of the player (centered)\n        self.y: int = sh // 2  # Initial y-coordinate of the player (centered)\n        self.angle = 0  # Initial angle of rotation\n        self.rotatedSurf = pygame.transform.rotate(\n            self.img, self.angle\n        )  # Rotated player image surface\n        self.rotatedRect = (\n            self.rotatedSurf.get_rect()\n        )  # Rectangular area of the rotated player image\n        self.rotatedRect.center = (self.x, self.y)  # Center of the rotated player image\n        self.cosine = math.cos(\n            math.radians(self.angle + 90)\n        )  # Cosine of the angle (used for direction calculation)\n        self.sine = math.sin(\n            math.radians(self.angle + 90)\n        )  # Sine of the angle (used for direction calculation)\n        self.head = (\n            self.x + self.cosine * self.w // 2,\n            self.y - self.sine * self.h // 2,\n        )  # Position of player head\n\n    def draw(self, win: Surface) -&gt; None:\n        \"\"\"Draw the player on the screen.\n\n        Args:\n            win: target window.\n        \"\"\"\n        win.blit(self.rotatedSurf, self.rotatedRect)\n\n    def rotate(self) -&gt; None:\n        \"\"\"Rotate the player image surface and update the rectangular area and head position.\"\"\"\n        self.rotatedSurf = pygame.transform.rotate(self.img, self.angle)\n        self.rotatedRect = self.rotatedSurf.get_rect()\n        self.rotatedRect.center = (self.x, self.y)\n        self.cosine = math.cos(math.radians(self.angle + 90))\n        self.sine = math.sin(math.radians(self.angle + 90))\n        self.head = (\n            self.x + self.cosine * self.w // 2,\n            self.y - self.sine * self.h // 2,\n        )\n\n    def turn(self, direction: Direction) -&gt; None:\n        \"\"\"Turn the player `left` or `right` by ``5`` degrees and update rotation.\n\n        Args:\n            direction: rotation direction.\n        \"\"\"\n        if direction == Direction.LEFT:\n            self.angle += 5\n        elif direction == Direction.RIGHT:\n            self.angle -= 5\n        self.rotate()\n\n    def move(self, direction: Direction) -&gt; None:\n        \"\"\"Move the player `forward` or `backward` based on its direction and update rotation.\n\n        Args:\n            direction: movment direction.\n        \"\"\"\n        if direction == Direction.FORWARD:\n            self.x += int(self.cosine * 6)\n            self.y -= int(self.sine * 6)\n        elif direction == Direction.BACKWARD:\n            self.x -= int(self.cosine * 6)\n            self.y += int(self.sine * 6)\n        self.rotate()\n\n    def updateLocation(self) -&gt; None:\n        \"\"\"Update player's location if it goes beyond screen boundaries.\"\"\"\n        if self.x &gt; self.sw + 50:\n            self.x = 0\n        elif self.x &lt; 0 - self.w:\n            self.x = self.sw\n        elif self.y &lt; -50:\n            self.y = self.sh\n        elif self.y &gt; self.sh + 50:\n            self.y = 0\n</code></pre>"},{"location":"api_reference/player_reference/#src.player.Player.draw","title":"<code>draw(win)</code>","text":"<p>Draw the player on the screen.</p> <p>Parameters:</p> Name Type Description Default <code>win</code> <code>Surface</code> <p>target window.</p> required Source code in <code>src/player.py</code> <pre><code>def draw(self, win: Surface) -&gt; None:\n    \"\"\"Draw the player on the screen.\n\n    Args:\n        win: target window.\n    \"\"\"\n    win.blit(self.rotatedSurf, self.rotatedRect)\n</code></pre>"},{"location":"api_reference/player_reference/#src.player.Player.move","title":"<code>move(direction)</code>","text":"<p>Move the player <code>forward</code> or <code>backward</code> based on its direction and update rotation.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>Direction</code> <p>movment direction.</p> required Source code in <code>src/player.py</code> <pre><code>def move(self, direction: Direction) -&gt; None:\n    \"\"\"Move the player `forward` or `backward` based on its direction and update rotation.\n\n    Args:\n        direction: movment direction.\n    \"\"\"\n    if direction == Direction.FORWARD:\n        self.x += int(self.cosine * 6)\n        self.y -= int(self.sine * 6)\n    elif direction == Direction.BACKWARD:\n        self.x -= int(self.cosine * 6)\n        self.y += int(self.sine * 6)\n    self.rotate()\n</code></pre>"},{"location":"api_reference/player_reference/#src.player.Player.rotate","title":"<code>rotate()</code>","text":"<p>Rotate the player image surface and update the rectangular area and head position.</p> Source code in <code>src/player.py</code> <pre><code>def rotate(self) -&gt; None:\n    \"\"\"Rotate the player image surface and update the rectangular area and head position.\"\"\"\n    self.rotatedSurf = pygame.transform.rotate(self.img, self.angle)\n    self.rotatedRect = self.rotatedSurf.get_rect()\n    self.rotatedRect.center = (self.x, self.y)\n    self.cosine = math.cos(math.radians(self.angle + 90))\n    self.sine = math.sin(math.radians(self.angle + 90))\n    self.head = (\n        self.x + self.cosine * self.w // 2,\n        self.y - self.sine * self.h // 2,\n    )\n</code></pre>"},{"location":"api_reference/player_reference/#src.player.Player.turn","title":"<code>turn(direction)</code>","text":"<p>Turn the player <code>left</code> or <code>right</code> by <code>5</code> degrees and update rotation.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>Direction</code> <p>rotation direction.</p> required Source code in <code>src/player.py</code> <pre><code>def turn(self, direction: Direction) -&gt; None:\n    \"\"\"Turn the player `left` or `right` by ``5`` degrees and update rotation.\n\n    Args:\n        direction: rotation direction.\n    \"\"\"\n    if direction == Direction.LEFT:\n        self.angle += 5\n    elif direction == Direction.RIGHT:\n        self.angle -= 5\n    self.rotate()\n</code></pre>"},{"location":"api_reference/player_reference/#src.player.Player.updateLocation","title":"<code>updateLocation()</code>","text":"<p>Update player's location if it goes beyond screen boundaries.</p> Source code in <code>src/player.py</code> <pre><code>def updateLocation(self) -&gt; None:\n    \"\"\"Update player's location if it goes beyond screen boundaries.\"\"\"\n    if self.x &gt; self.sw + 50:\n        self.x = 0\n    elif self.x &lt; 0 - self.w:\n        self.x = self.sw\n    elif self.y &lt; -50:\n        self.y = self.sh\n    elif self.y &gt; self.sh + 50:\n        self.y = 0\n</code></pre>"},{"location":"api_reference/virus_reference/","title":"Virus module","text":""},{"location":"api_reference/virus_reference/#virus-class","title":"Virus class","text":"<p>             Bases: <code>GameObject</code></p> Source code in <code>src/virus.py</code> <pre><code>class Virus(GameObject):\n    def __init__(self, sw: int, sh: int, rank: int, images: list[Surface]) -&gt; None:\n        super().__init__(sw, sh, images[0])\n        \"\"\"Initialize a virus object.\n\n        Args:\n            sw (int): Screen width.\n            sh (int): Screen height.\n            rank (int): Rank of the virus.\n            images (list): List of images for different ranks of the virus.\n        \"\"\"\n        self.rank = rank\n        # Select image based on virus rank\n        if self.rank == 1:\n            self.image = images[0]\n        elif self.rank == 2:\n            self.image = images[1]\n        else:\n            self.image = images[2]\n\n        # Set width and height based on virus rank\n        self.w = 50 * rank\n        self.h = 50 * rank\n\n        # Randomize initial position\n        self.ranPoint = random.choice(\n            [\n                (\n                    random.randrange(0, sw - self.w),\n                    random.choice([-1 * self.h - 5, sh + 5]),\n                ),\n                (\n                    random.choice([-1 * self.w - 5, sw + 5]),\n                    random.randrange(0, sh - self.h),\n                ),\n            ]\n        )\n        self.x, self.y = self.ranPoint\n\n        # Determine initial direction based on position\n        if self.x &lt; sw // 2:\n            self.x_dir = 1\n        else:\n            self.x_dir = -1\n        if self.y &lt; sh // 2:\n            self.y_dir = 1\n        else:\n            self.y_dir = -1\n\n        # Set random velocities\n        self.xv = self.x_dir * random.randrange(1, 3)\n        self.yv = self.y_dir * random.randrange(1, 3)\n\n    def draw(self, win: Surface) -&gt; None:\n        \"\"\"Draw the virus on the window.\n\n        Args:\n            win: Pygame window surface.\n        \"\"\"\n        win.blit(self.image, (self.x, self.y))\n</code></pre>"},{"location":"api_reference/virus_reference/#src.virus.Virus.draw","title":"<code>draw(win)</code>","text":"<p>Draw the virus on the window.</p> <p>Parameters:</p> Name Type Description Default <code>win</code> <code>Surface</code> <p>Pygame window surface.</p> required Source code in <code>src/virus.py</code> <pre><code>def draw(self, win: Surface) -&gt; None:\n    \"\"\"Draw the virus on the window.\n\n    Args:\n        win: Pygame window surface.\n    \"\"\"\n    win.blit(self.image, (self.x, self.y))\n</code></pre>"}]}