{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ZZPO","text":"<p>Celem naszego projektu jest stworzenie gry 2D kt\u00f3rej logika jest wzorowana na popularnej grze \u201cAsteroids\u201d. W naszej grze gracz wciela si\u0119 w posta\u0107 z popularnej kresk\u00f3wki i walczy ze z\u0142ymi bakteriami i wirusami.</p>"},{"location":"#wymagania-funkcjonalne","title":"Wymagania funkcjonalne","text":"<ul> <li>Gracz mo\u017ce kontrolowa\u0107 swoj\u0105 posta\u0107 poprzez ruch prz\u00f3d, ty\u0142, obr\u00f3t w prawo, obr\u00f3t w lewo oraz strza\u0142.</li> <li>Gra generuje losowych przeciwnik\u00f3w, kt\u00f3rzy poruszaj\u0105 si\u0119 ruchem jednostajnym prostoliniowym.</li> <li>Gracz mo\u017ce niszczy\u0107 przeciwnik\u00f3w poprzez strzelanie do nich.</li> <li>Niekt\u00f3rzy przeciwnicy r\u00f3wnie\u017c posiadaj\u0105 mo\u017cliwo\u015b\u0107 strzelania.</li> <li>Przeciwnik po trafieniu rozpada si\u0119 na mniejsze cz\u0119\u015bci lub ulega ca\u0142kowitemu zniszczeniu.</li> <li>Gracz traci \u017cycia w momencie zderzenia lub trafieniu wrogim pociskiem.</li> <li>Gracz zwi\u0119ksza sw\u00f3j wynik poprzez trafianie przeciwnik\u00f3w.</li> </ul>"},{"location":"#wymagania-niefunkcjonalne","title":"Wymagania niefunkcjonalne","text":"<ul> <li>Gra desktopowa, napisana w j\u0119zyku python z wykorzystaniem biblioteki pygames.</li> </ul>"},{"location":"#pojecia","title":"Poj\u0119cia","text":"<ul> <li><code>Gracz</code>: posta\u0107 sterowana przez osob\u0119 graj\u0105c\u0105 w gr\u0119.</li> <li><code>Przeciwnik</code>: posta\u0107 sterowana przez komputer.</li> <li><code>Trafienie</code>: kolizja pocisku z graczem lub przeciwnikiem.</li> <li><code>Zderzenie</code>: kolizja gracza z przeciwnikiem.</li> <li><code>Obra\u017cenia</code>: \u0142\u0105czna suma zderze\u0144 i kolizji gracza z przeciwnikiem.</li> <li><code>\u017bycia</code>: maksymalna ilo\u015b\u0107 obra\u017ce\u0144 mo\u017cliwa do przyj\u0119cia.</li> <li><code>Wynik</code>: suma punkt\u00f3w uzyskanych za trafienia przeciwnik\u00f3w.</li> </ul>"},{"location":"api_reference/player_reference/","title":"Player module","text":""},{"location":"api_reference/player_reference/#direction-class","title":"Direction class","text":"<p>             Bases: <code>StrEnum</code></p> Source code in <code>src/player.py</code> <pre><code>class Direction(StrEnum):\n    FORWARD = \"forward\"\n    BACKWARD = \"backward\"\n    LEFT = \"left\"\n    RIGHT = \"right\"\n</code></pre>"},{"location":"api_reference/player_reference/#player-class","title":"Player class","text":"<p>             Bases: <code>GameObject</code></p> <p>The class representing a character controlled by the player.</p> Source code in <code>src/player.py</code> <pre><code>class Player(GameObject):\n    \"\"\"The class representing a character controlled by the player.\"\"\"\n\n    def __init__(self, sw: int, sh: int, image: Surface) -&gt; None:\n        super().__init__(sw, sh, image)\n        self.x: int = sw // 2  # Initial x-coordinate of the player (centered)\n        self.y: int = sh // 2  # Initial y-coordinate of the player (centered)\n        self.angle = 0  # Initial angle of rotation\n        self.rotatedSurf = pygame.transform.rotate(\n            self.img, self.angle\n        )  # Rotated player image surface\n        self.rotatedRect = (\n            self.rotatedSurf.get_rect()\n        )  # Rectangular area of the rotated player image\n        self.rotatedRect.center = (self.x, self.y)  # Center of the rotated player image\n        self.cosine = math.cos(\n            math.radians(self.angle + 90)\n        )  # Cosine of the angle (used for direction calculation)\n        self.sine = math.sin(\n            math.radians(self.angle + 90)\n        )  # Sine of the angle (used for direction calculation)\n        self.head = (\n            self.x + self.cosine * self.w // 2,\n            self.y - self.sine * self.h // 2,\n        )  # Position of player head\n\n    def draw(self, win: Surface) -&gt; None:\n        \"\"\"Draw the player on the screen.\n\n        Args:\n            win: target window.\n        \"\"\"\n        win.blit(self.rotatedSurf, self.rotatedRect)\n\n    def rotate(self) -&gt; None:\n        \"\"\"Rotate the player image surface and update the rectangular area and head position.\"\"\"\n        self.rotatedSurf = pygame.transform.rotate(self.img, self.angle)\n        self.rotatedRect = self.rotatedSurf.get_rect()\n        self.rotatedRect.center = (self.x, self.y)\n        self.cosine = math.cos(math.radians(self.angle + 90))\n        self.sine = math.sin(math.radians(self.angle + 90))\n        self.head = (\n            self.x + self.cosine * self.w // 2,\n            self.y - self.sine * self.h // 2,\n        )\n\n    def turn(self, direction: Direction) -&gt; None:\n        \"\"\"Turn the player `left` or `right` by ``5`` degrees and update rotation.\n\n        Args:\n            direction: rotation direction.\n        \"\"\"\n        if direction == Direction.LEFT:\n            self.angle += 5\n        elif direction == Direction.RIGHT:\n            self.angle -= 5\n        self.rotate()\n\n    def move(self, direction: Direction) -&gt; None:\n        \"\"\"Move the player `forward` or `backward` based on its direction and update rotation.\n\n        Args:\n            direction: movment direction.\n        \"\"\"\n        if direction == Direction.FORWARD:\n            self.x += int(self.cosine * 6)\n            self.y -= int(self.sine * 6)\n        elif direction == Direction.BACKWARD:\n            self.x -= int(self.cosine * 6)\n            self.y += int(self.sine * 6)\n        self.rotate()\n\n    def updateLocation(self) -&gt; None:\n        \"\"\"Update player's location if it goes beyond screen boundaries.\"\"\"\n        if self.x &gt; self.sw + 50:\n            self.x = 0\n        elif self.x &lt; 0 - self.w:\n            self.x = self.sw\n        elif self.y &lt; -50:\n            self.y = self.sh\n        elif self.y &gt; self.sh + 50:\n            self.y = 0\n</code></pre>"},{"location":"api_reference/player_reference/#src.player.Player.draw","title":"<code>draw(win)</code>","text":"<p>Draw the player on the screen.</p> <p>Parameters:</p> Name Type Description Default <code>win</code> <code>Surface</code> <p>target window.</p> required Source code in <code>src/player.py</code> <pre><code>def draw(self, win: Surface) -&gt; None:\n    \"\"\"Draw the player on the screen.\n\n    Args:\n        win: target window.\n    \"\"\"\n    win.blit(self.rotatedSurf, self.rotatedRect)\n</code></pre>"},{"location":"api_reference/player_reference/#src.player.Player.move","title":"<code>move(direction)</code>","text":"<p>Move the player <code>forward</code> or <code>backward</code> based on its direction and update rotation.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>Direction</code> <p>movment direction.</p> required Source code in <code>src/player.py</code> <pre><code>def move(self, direction: Direction) -&gt; None:\n    \"\"\"Move the player `forward` or `backward` based on its direction and update rotation.\n\n    Args:\n        direction: movment direction.\n    \"\"\"\n    if direction == Direction.FORWARD:\n        self.x += int(self.cosine * 6)\n        self.y -= int(self.sine * 6)\n    elif direction == Direction.BACKWARD:\n        self.x -= int(self.cosine * 6)\n        self.y += int(self.sine * 6)\n    self.rotate()\n</code></pre>"},{"location":"api_reference/player_reference/#src.player.Player.rotate","title":"<code>rotate()</code>","text":"<p>Rotate the player image surface and update the rectangular area and head position.</p> Source code in <code>src/player.py</code> <pre><code>def rotate(self) -&gt; None:\n    \"\"\"Rotate the player image surface and update the rectangular area and head position.\"\"\"\n    self.rotatedSurf = pygame.transform.rotate(self.img, self.angle)\n    self.rotatedRect = self.rotatedSurf.get_rect()\n    self.rotatedRect.center = (self.x, self.y)\n    self.cosine = math.cos(math.radians(self.angle + 90))\n    self.sine = math.sin(math.radians(self.angle + 90))\n    self.head = (\n        self.x + self.cosine * self.w // 2,\n        self.y - self.sine * self.h // 2,\n    )\n</code></pre>"},{"location":"api_reference/player_reference/#src.player.Player.turn","title":"<code>turn(direction)</code>","text":"<p>Turn the player <code>left</code> or <code>right</code> by <code>5</code> degrees and update rotation.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>Direction</code> <p>rotation direction.</p> required Source code in <code>src/player.py</code> <pre><code>def turn(self, direction: Direction) -&gt; None:\n    \"\"\"Turn the player `left` or `right` by ``5`` degrees and update rotation.\n\n    Args:\n        direction: rotation direction.\n    \"\"\"\n    if direction == Direction.LEFT:\n        self.angle += 5\n    elif direction == Direction.RIGHT:\n        self.angle -= 5\n    self.rotate()\n</code></pre>"},{"location":"api_reference/player_reference/#src.player.Player.updateLocation","title":"<code>updateLocation()</code>","text":"<p>Update player's location if it goes beyond screen boundaries.</p> Source code in <code>src/player.py</code> <pre><code>def updateLocation(self) -&gt; None:\n    \"\"\"Update player's location if it goes beyond screen boundaries.\"\"\"\n    if self.x &gt; self.sw + 50:\n        self.x = 0\n    elif self.x &lt; 0 - self.w:\n        self.x = self.sw\n    elif self.y &lt; -50:\n        self.y = self.sh\n    elif self.y &gt; self.sh + 50:\n        self.y = 0\n</code></pre>"}]}